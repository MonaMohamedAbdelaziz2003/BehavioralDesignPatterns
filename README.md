# BehavioralDesignPatterns :
<h4><li>Behavioral design patterns are a subset of design patterns in software engineering that deal with the interaction and responsibilities of objects. These patterns focus on how objects communicate and work together to achieve common tasks</li></h4>
<h4><li>Behavioral design patterns are concerned with algorithms and the assignment of responsibilities between objects.</li> </h4>
<hr>

<h3><a href="Chain of Responsibility">1- Chain of Responsibility</a></h3>
<li>
 Chain of Responsibility is a behavioral design pattern that lets
 you pass requests along a chain of handlers. Upon receiving a
 request, each handler decides either to process the request or
 to pass it to the next handler in the chain
</li>
  <br>
  <br>
<img src="https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/structure-indexed.png">
<hr>

<h3><a href="command">2- Command</a></h3>
<li>
 Command is a behavioral design pattern that turns a request
 into a stand-alone object that contains all information about
 the request. This transformation lets you parameterize
 methods with different requests, delay or queue a request’s
 execution, and support undoable operations.
</li>
  <br>
  <br>
<img src="https://refactoring.guru/images/patterns/diagrams/command/structure-indexed.png">
<hr>

<h3><a href="iterator">3- Iterator</a></h3>
<li>
Iterator is a behavioral design pattern that lets you traverse
 elements of a collection without exposing its underlying
 representation (list, stack, tree, etc.)
</li>
  <br>
  <br>
<img src="https://refactoring.guru/images/patterns/diagrams/iterator/structure-indexed.png">
<hr>



<h3><a href="Mediator">4- Mediator</a></h3>
<li>
 Mediator is a behavioral design pattern that lets you reduce
 chaotic dependencies between objects. The pattern restricts
 direct communications between the objects and forces them to
 collaborate only via a mediator object.
</li>
  <br>
  <br>
<img src="https://refactoring.guru/images/patterns/diagrams/mediator/structure-indexed.png">
<hr>


<h3><a href="Memento">5- Memento</a></h3>
<li>
Memento is a behavioral design pattern that lets you save and
 restore the previous state of an object without revealing the
 details of its implementation
</li>
  <br>
  <br>
<img src="https://refactoring.guru/images/patterns/diagrams/memento/structure1-indexed.png">
<hr>


<h3><a href="Observer">6- Observer</a></h3>
<li>
Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.
</li>
  <br>
  <br>
<img src="https://refactoring.guru/images/patterns/diagrams/observer/structure-indexed.png">
<hr>


<h3><a href="State">7- State</a></h3>
<li>
State is a behavioral design pattern that lets an object alter its
behavior when its internal state changes. It appears as if the
object changed its class.</li>
  <br>
  <br>
<img src="https://refactoring.guru/images/patterns/diagrams/state/structure-en-indexed.png">
<hr>


<h3><a href="Strategy">8- Strategy</a></h3>
<li>
Strategy is a behavioral design pattern that lets you define a
family of algorithms, put each of them into a separate class,
and make their objects interchangeable.</li>
  <br>
  <br>
<img src="https://refactoring.guru/images/patterns/diagrams/strategy/structure-indexed.png">
<hr>


<h3><a href="Template">9-Template</a></h3>
<li>
Template Method is a behavioral design pattern that defines
the skeleton of an algorithm in the superclass but lets
subclasses override specific steps of the algorithm without
changing its structure.</li>
  <br>
  <br>
<img src="https://refactoring.guru/images/patterns/diagrams/template-method/structure-2x.png">
<hr>
